exports.id=407,exports.ids=[407],exports.modules={4345:(e,t,o)=>{o.d(t,{ComposerWebviewProvider:()=>ComposerWebviewProvider});var n=o(1398),i=o(4252),s=o(4937),a=o(2767),r=o(2139),c=o(1628),d=o(1377),m=o(5570),h=o(7382),l=o(8952);let u="1.0.0",g={hunks:[],commits:[],hunkMap:[],baseCommit:{sha:"",message:"",repoName:"",branchName:""},safetyState:{repoPath:"",headSha:"",hashes:{staged:null,unstaged:null,unified:null}},selectedCommitId:null,selectedCommitIds:new Set,selectedUnassignedSection:null,selectedHunkIds:new Set,detailsSectionExpanded:{commitMessage:!0,aiExplanation:!0,filesChanged:!0},generatingCommits:!1,generatingCommitMessage:null,committing:!1,safetyError:null,loadingError:null,aiOperationError:null,hasUsedAutoCompose:!1,hasChanges:!0,workingDirectoryHasChanged:!1,indexHasChanged:!1,mode:"preview",aiEnabled:{org:!1,config:!1},ai:{model:void 0},onboardingDismissed:!1},p={sessionStart:"",sessionDuration:void 0,diff:{files:0,hunks:0,lines:0,staged:!1,unstaged:!1,unstagedIncluded:!1},commits:{initialCount:0,autoComposedCount:void 0,composedCount:void 0,finalCount:void 0},ai:{enabled:{org:!1,config:!1},model:void 0},onboarding:{dismissed:!1,stepReached:void 0},operations:{generateCommits:{count:0,cancelledCount:0,errorCount:0,feedback:{upvoteCount:0,downvoteCount:0}},generateCommitMessage:{count:0,cancelledCount:0,errorCount:0},finishAndCommit:{errorCount:0},undo:{count:0},redo:{count:0},reset:{count:0}},source:void 0,mode:"preview",errors:{safety:{count:0},operation:{count:0}},warnings:{workingDirectoryChanged:!1,indexChanged:!1}},f="composer",C=new l.Q2(f,"generateCommits"),x=new l.Q2(f,"generateCommitMessage"),y=new l.Q2(f,"finishAndCommit"),w=new l.Q2(f,"close"),_=new l.Q2(f,"reload"),b=new l.Q2(f,"cancelGenerateCommits"),v=new l.Q2(f,"cancelGenerateCommitMessage");new l.Q2(f,"cancelFinishAndCommit");let k=new l.Q2(f,"clearAIOperationError"),E=new l.Q2(f,"selectAIModel"),I=new l.Q2(f,"aiFeedbackHelpful"),R=new l.Q2(f,"aiFeedbackUnhelpful"),S=new l.Q2(f,"openOnboarding"),M=new l.Q2(f,"dismissOnboarding"),A=new l.Q2(f,"advanceOnboarding"),T=new l.Q2("composer","chooseRepository"),D=new l.Q2(f,"onAddHunksToCommit"),O=new l.Q2(f,"onUndo"),H=new l.Q2(f,"onRedo"),F=new l.Q2(f,"onReset");new l.C1(f,"didChange");let P=new l.C1(f,"didStartGenerating"),N=new l.C1(f,"didStartGeneratingCommitMessage"),$=new l.C1(f,"didGenerateCommits"),Q=new l.C1(f,"didGenerateCommitMessage"),G=new l.C1(f,"didStartCommitting"),U=new l.C1(f,"didFinishCommitting"),W=new l.C1(f,"didSafetyError"),B=new l.C1(f,"didReloadComposer"),z=new l.C1(f,"didLoadingError"),q=new l.C1(f,"didWorkingDirectoryChange"),j=new l.C1(f,"didIndexChange"),L=new l.C1(f,"didCancelGenerateCommits"),V=new l.C1(f,"didCancelGenerateCommitMessage"),Z=new l.C1(f,"didErrorAIOperation"),J=new l.C1(f,"didClearAIOperationError"),K=new l.C1(f,"didChangeAiEnabled"),X=new l.C1(f,"didChangeAiModel");var Y=o(8640),ee=o(413);function et(e,t,o){let n=[],i=[],s=o;for(let o of e.files)if(o.hunks.length)for(let e of o.hunks){let a=++s;n.push({index:a,hunkHeader:e.header});let{additions:r,deletions:c}=function(e){let t=e.split(`
`),o=0,n=0;for(let e of t)e.startsWith("+")&&!e.startsWith("+++")?o++:e.startsWith("-")&&!e.startsWith("---")&&n++;return{additions:o,deletions:n}}(e.content),d={index:a,fileName:o.path,originalFileName:o.originalPath,diffHeader:o.header,hunkHeader:e.header,content:e.content,additions:r,deletions:c,source:t,assigned:!1,isRename:!1};i.push(d)}else{let e,a,r=++s;if(o.metadata.binary)e="binary",a="Binary file";else if(o.metadata.modeChanged)e="mode change",a=`Mode change from ${o.metadata.modeChanged.oldMode||"?"} to ${o.metadata.modeChanged.newMode||"?"}`;else if(o.metadata.renamedOrCopied){e="rename";let t=o.metadata.renamedOrCopied?.similarity||100;a=`Rename from ${o.originalPath}
Rename to ${o.path}
Similarity index ${t}%`}else e="no-content-change",a=o.header.split(`
`).slice(1).join(`
`);n.push({index:r,hunkHeader:e});let c={index:r,fileName:o.path,originalFileName:o.originalPath,diffHeader:o.header,hunkHeader:e,content:a,additions:0,deletions:0,source:t,assigned:!1,isRename:!1!==o.metadata.renamedOrCopied};i.push(c)}return{hunkMap:n,hunks:i,count:s}}async function eo(e){let[t,o,n]=await Promise.allSettled([e.git.diff.getDiff?.(Y.id),e.git.diff.getDiff?.(Y.SU),e.git.diff.getDiff?.(Y.SU,"HEAD",{notation:"..."})]);return{staged:(0,m.Ro)(t),unstaged:(0,m.Ro)(o),unified:(0,m.Ro)(n)}}async function en(e,t,o){if(!o)throw Error("Cannot create safety state: no HEAD commit found");return{repoPath:e.path,headSha:o,hashes:{staged:t.staged?.contents?await (0,i.sc)(t.staged.contents):null,unstaged:t.unstaged?.contents?await (0,i.sc)(t.unstaged.contents):null,unified:t.unified?.contents?await (0,i.sc)(t.unified.contents):null}}}async function ei(e,t,o){let n=[];try{e.path!==t.repoPath&&n.push(`Repository path changed from "${t.repoPath}" to "${e.path}"`);let s=await e.git.commits.getCommit("HEAD"),a=s?.sha??"unknown";if(a!==t.headSha&&n.push(`HEAD commit changed from "${t.headSha}" to "${a}"`),o?.length){let{staged:s,unstaged:a}=await eo(e),r={staged:s?.contents?await (0,i.sc)(s.contents):null,unstaged:a?.contents?await (0,i.sc)(a.contents):null};o.some(e=>"staged"===e.source)&&r.staged!==t.hashes.staged&&n.push("Staged changes have been modified since composer opened"),o.some(e=>"unstaged"===e.source)&&r.unstaged!==t.hashes.unstaged&&n.push("Unstaged changes have been modified since composer opened")}return{isValid:!n.length,errors:n}}catch(e){return n.push(`Failed to validate repository state: ${e instanceof Error?e.message:"Unknown error"}`),{isValid:!1,errors:n}}}let ComposerWebviewProvider=class ComposerWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=n.Disposable.from(c.H.onDidChangeAny(this.onAnyConfigurationChanged,this),(0,d.wt)(this.onContextChanged,this),this.container.ai.onDidChangeModel(this.onAIModelChanged,this)),this._context={...p}}_disposable;_args;_cache=new h.o({accessTTL:3e5});_generateCommitsCancellation;_generateCommitMessageCancellation;_repositorySubscription;_currentRepository;_context;dispose(){this._cache.clear(),this.resetContext(),this._generateCommitsCancellation?.dispose(),this._generateCommitMessageCancellation?.dispose(),this._repositorySubscription?.dispose(),this._disposable.dispose()}onMessageReceived(e){switch(!0){case C.is(e):this.onGenerateCommits(e.params);break;case x.is(e):this.onGenerateCommitMessage(e.params);break;case y.is(e):this.onFinishAndCommit(e.params);break;case w.is(e):this.close();break;case _.is(e):this.onReloadComposer(e.params);break;case E.is(e):this.onSelectAIModel();break;case I.is(e):this.onAIFeedbackHelpful(e.params);break;case R.is(e):this.onAIFeedbackUnhelpful(e.params);break;case b.is(e):this.onCancelGenerateCommits();break;case v.is(e):this.onCancelGenerateCommitMessage();break;case k.is(e):this.onClearAIOperationError();break;case S.is(e):this.onOpenOnboarding();break;case A.is(e):this.onAdvanceOnboarding(e.params);break;case M.is(e):this.onDismissOnboarding();break;case D.is(e):this.onAddHunksToCommit(e.params);break;case O.is(e):this.onUndo();break;case H.is(e):this.onRedo();break;case F.is(e):this.onReset();break;case T.is(e):this.onChooseRepository()}}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.session.start":this._context.sessionStart,"context.session.duration":this._context.sessionDuration,"context.source":this._context.source,"context.mode":this._context.mode,"context.diff.files.count":this._context.diff.files,"context.diff.hunks.count":this._context.diff.hunks,"context.diff.lines.count":this._context.diff.lines,"context.diff.staged.exists":this._context.diff.staged,"context.diff.unstaged.exists":this._context.diff.unstaged,"context.diff.unstaged.included":this._context.diff.unstagedIncluded,"context.commits.initialCount":this._context.commits.initialCount,"context.commits.autoComposedCount":this._context.commits.autoComposedCount,"context.commits.composedCount":this._context.commits.composedCount,"context.commits.finalCount":this._context.commits.finalCount,"context.ai.enabled.config":this._context.ai.enabled.config,"context.ai.enabled.org":this._context.ai.enabled.org,"context.ai.model.id":this._context.ai.model?.id,"context.ai.model.name":this._context.ai.model?.name,"context.ai.model.provider.id":this._context.ai.model?.provider.id,"context.ai.model.temperature":this._context.ai.model?.temperature??void 0,"context.ai.model.maxTokens.input":this._context.ai.model?.maxTokens.input,"context.ai.model.maxTokens.output":this._context.ai.model?.maxTokens.output,"context.ai.model.default":this._context.ai.model?.default,"context.ai.model.hidden":this._context.ai.model?.hidden,"context.onboarding.stepReached":this._context.onboarding.stepReached,"context.onboarding.dismissed":this._context.onboarding.dismissed,"context.operations.generateCommits.count":this._context.operations.generateCommits.count,"context.operations.generateCommits.cancelled.count":this._context.operations.generateCommits.cancelledCount,"context.operations.generateCommits.error.count":this._context.operations.generateCommits.errorCount,"context.operations.generateCommits.feedback.upvote.count":this._context.operations.generateCommits.feedback.upvoteCount,"context.operations.generateCommits.feedback.downvote.count":this._context.operations.generateCommits.feedback.downvoteCount,"context.operations.generateCommitMessage.count":this._context.operations.generateCommitMessage.count,"context.operations.generateCommitMessage.cancelled.count":this._context.operations.generateCommitMessage.cancelledCount,"context.operations.generateCommitMessage.error.count":this._context.operations.generateCommitMessage.errorCount,"context.operations.finishAndCommit.error.count":this._context.operations.finishAndCommit.errorCount,"context.operations.undo.count":this._context.operations.undo.count,"context.operations.redo.count":this._context.operations.redo.count,"context.operations.reset.count":this._context.operations.reset.count,"context.warnings.workingDirectoryChanged":this._context.warnings.workingDirectoryChanged,"context.warnings.indexChanged":this._context.warnings.indexChanged,"context.errors.safety.count":this._context.errors.safety.count,"context.errors.operation.count":this._context.errors.operation.count}}includeBootstrap(){return this._cache.get("bootstrap",()=>this.getBootstrapState())}async getBootstrapState(){let e;this.container.git.isDiscoveringRepositories&&await this.container.git.isDiscoveringRepositories;let t=this._args;return null==(e=t?.repoPath!=null?this.container.git.getRepository(t.repoPath):this.container.git.getBestRepositoryOrFirst())?{...this.initialState,loadingError:"No repository found. Please open a Git repository to use the Commit Composer."}:this.createInitialStateFromRepo(e,t?.includedUnstagedChanges,t?.mode,t?.source)}get initialState(){return{...this.host.baseWebviewState,...g}}async createInitialStateFromRepo(e,t,o="preview",n,i){let[s,a,r]=await Promise.allSettled([eo(e),e.git.commits.getCommit("HEAD"),e.git.branches.getBranch()]),c=(0,m.Ro)(s);this._context.diff.unstagedIncluded=!1,t&&(this._context.diff.unstagedIncluded=!0);let d=this._context.diff.unstagedIncluded?c?.unified:c?.staged,h=this._context.diff.unstagedIncluded?void 0:c?.unstaged;!c?.staged?.contents&&c?.unstaged?.contents&&(this._context.diff.unstagedIncluded=!0);let l=!!(d?.contents||h?.contents),{hunkMap:u,hunks:g}=function(e,t){let o=[],n=[],i=0,s=[],a=[];if(e){let t=(0,ee.Tc)(e);({hunkMap:s,hunks:a,count:i}=et(t,"staged",i)),o.push(...s),n.push(...a)}if(t){let e=(0,ee.Tc)(t);({hunkMap:s,hunks:a,count:i}=et(e,"unstaged",i)),o.push(...s),n.push(...a)}return{hunkMap:o,hunks:n}}(d?.contents,h?.contents),p=(0,m.Ro)(a);if(null==p){let e="No base commit found to compose from.";return this.sendTelemetryEvent(i?"composer/reloaded":"composer/loaded",{"failure.reason":"error","failure.error.message":e}),{...this.initialState,loadingError:e}}let f=(0,m.Ro)(r);if(null==f){let e="No current branch found to compose from.";return this.sendTelemetryEvent(i?"composer/reloaded":"composer/loaded",{"failure.reason":"error","failure.error.message":e}),{...this.initialState,loadingError:e}}let C=!!d?.contents,x=!!h?.contents,y={id:"draft-commit-1",message:"",aiExplanation:"",hunkIndices:C&&x?g.filter(e=>"staged"===e.source).map(e=>e.index):g.map(e=>e.index)},w=await en(e,c,p.sha),_=this.getAiEnabled(),b=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId}),v=this.isOnboardingDismissed(),k=this.getOnboardingStepReached();return this._context.diff.files=new Set(g.map(e=>e.fileName)).size,this._context.diff.hunks=g.length,this._context.diff.lines=g.reduce((e,t)=>e+t.content.split(`
`).length-1,0),this._context.diff.staged=C,this._context.diff.unstaged=x,this._context.commits.initialCount=0,this._context.ai.enabled.org=_.org,this._context.ai.enabled.config=_.config,this._context.ai.model=b,this._context.onboarding.dismissed=v,this._context.onboarding.stepReached=k,this._context.source=n,this._context.mode=o,this._context.warnings.workingDirectoryChanged=!1,this._context.warnings.indexChanged=!1,this._context.sessionStart=new Date().toISOString(),this.sendTelemetryEvent(i?"composer/reloaded":"composer/loaded"),this.subscribeToRepository(e),{...this.initialState,hunks:g,hunkMap:u,baseCommit:{sha:p.sha,message:p.message??"",repoName:e.name,branchName:f.name},commits:l?[y]:[],safetyState:w,aiEnabled:_,ai:{model:b},hasChanges:l,mode:o,onboardingDismissed:v,workingDirectoryHasChanged:!1,indexHasChanged:!1,repositoryState:this.getRepositoryState()}}getRepositoryState(){if(null==this._currentRepository)return;let{id:e,name:t,path:o,uri:n,virtual:i}=this._currentRepository;return{current:{id:e,name:t,path:o,uri:n.toString(),virtual:i},hasMultipleRepositories:this.container.git.openRepositoryCount>1}}async onAddHunksToCommit(e){"unstaged"===e.source&&(this._context.diff.unstagedIncluded=!0,this.sendTelemetryEvent("composer/action/includedUnstagedChanges"),await this.onReloadComposer({repoPath:this._currentRepository.path,mode:this._context.mode}))}onUndo(){this._context.operations.undo.count++,this.sendTelemetryEvent("composer/action/undo")}onRedo(){this._context.operations.redo.count++}onReset(){this._context.operations.reset.count++,this.sendTelemetryEvent("composer/action/reset")}async onChooseRepository(){let{title:e,placeholder:t}=await (0,r.Nt)(this.container.git.openRepositories,"Switch",this._currentRepository?.name),o=await (0,r.oe)(this.container,e,t,this.container.git.openRepositories,{picked:this._currentRepository});null!=o&&await this.onReloadComposer({repoPath:o.path,source:"composer"})}async onReloadComposer(e){try{this._cache.clear();let t=this._currentRepository;if((!t||null!=e.repoPath&&t?.path!==e.repoPath)&&!(t=null==e.repoPath?this.container.git.getBestRepositoryOrFirst():this.container.git.getRepository(e.repoPath))){this._context.errors.safety.count++;let e="Repository is no longer available";this.sendTelemetryEvent("composer/reloaded",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(W,{error:e});return}let o=await this.createInitialStateFromRepo(t,this._context.diff.unstagedIncluded,e.mode,e.source,!0);if(o.loadingError)return void await this.host.notify(z,{error:o.loadingError});await this.host.notify(B,{hunks:o.hunks,commits:o.commits,hunkMap:o.hunkMap,baseCommit:o.baseCommit,safetyState:o.safetyState,loadingError:o.loadingError,hasChanges:o.hasChanges,repositoryState:o.repositoryState})}catch(e){this.sendTelemetryEvent("composer/reloaded",{"failure.reason":"error","failure.error.message":e instanceof Error?e.message:"unknown error"}),await this.host.notify(z,{error:e instanceof Error?e.message:"Failed to reload composer"})}}async onCancelGenerateCommits(){this._generateCommitsCancellation&&(this._generateCommitsCancellation.cancel(),await this.host.notify(L,void 0))}async onCancelGenerateCommitMessage(){this._generateCommitMessageCancellation&&(this._generateCommitMessageCancellation.cancel(),await this.host.notify(V,void 0))}async onClearAIOperationError(){await this.host.notify(J,void 0)}onOpenOnboarding(){this.advanceOnboardingStep(1)}onAdvanceOnboarding(e){this.advanceOnboardingStep(e.stepNumber)}advanceOnboardingStep(e){if(this.isOnboardingDismissed())return;let t=Math.max(this.container.storage.get("composer:onboarding:stepReached")??1,e);this._context.onboarding.stepReached=t,this.container.storage.store("composer:onboarding:stepReached",t).catch()}onDismissOnboarding(){this.isOnboardingDismissed()||(this._context.onboarding.dismissed=!0,this.container.storage.store("composer:onboarding:dismissed",u).catch())}isOnboardingDismissed(){return this.container.storage.get("composer:onboarding:dismissed")===u}getOnboardingStepReached(){return this.container.storage.get("composer:onboarding:stepReached")}resetContext(){this._context={...p}}onShowing(e,t,...o){return o?.[0]&&(this._cache.clear(),this.resetContext(),this._args=o[0],this.updateTitle(o[0].mode)),[!0,void 0]}updateTitle(e){"experimental"===(e??this._args?.mode??"preview")?this.host.title="Commit Composer (Experimental)":this.host.title="Commit Composer (Preview)"}async close(){this._context.sessionDuration=Date.now()-new Date(this._context.sessionStart).getTime(),await n.commands.executeCommand("workbench.action.closeActiveEditor")}async updateAiModel(){try{let e=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId});this._context.ai.model=e,this.sendTelemetryEvent("composer/action/changeAiModel"),await this.host.notify(X,{model:e})}catch{}}async onSelectAIModel(){await n.commands.executeCommand("gitlens.ai.switchProvider",{source:"composer",correlationId:this.host.instanceId,detail:"model-picker"})}async onAIFeedbackHelpful(e){this._context.operations.generateCommits.feedback.upvoteCount++,await this.sendComposerAIFeedback("helpful",e.sessionId)}async onAIFeedbackUnhelpful(e){this._context.operations.generateCommits.feedback.downvoteCount++,await this.sendComposerAIFeedback("unhelpful",e.sessionId)}async sendComposerAIFeedback(e,t){try{let o,n=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId});if(!n)return;let i={id:t||"composer-session",type:"generate-commits",feature:"composer",model:{id:n.id,name:n.name,maxTokens:n.maxTokens,provider:{id:n.provider.id,name:n.provider.name},default:n.default,hidden:n.hidden,temperature:n.temperature},usage:void 0};if("unhelpful"===e&&(o=await (0,a.E)(),void 0===o))return;(0,a._)(this.container,{source:"composer",correlationId:this.host.instanceId},i,e,o)}catch{}}subscribeToRepository(e){this._repositorySubscription?.dispose(),this._currentRepository=e,this._repositorySubscription=n.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(this.onRepositoryFileSystemChanged,this),e.onDidChange(this.onRepositoryChanged,this))}async onRepositoryChanged(e){e.repository.id===this._currentRepository?.id&&e.changed(s.Z_.Index,s.Ti.Any)&&(this._context.warnings.indexChanged=!0,await this.host.notify(j,void 0))}async onRepositoryFileSystemChanged(e){e.repository.id===this._currentRepository?.id&&(this._context.warnings.workingDirectoryChanged=!0,await this.host.notify(q,void 0))}async onGenerateCommits(e){let t={"customInstructions.used":!1,"customInstructions.length":0,"customInstructions.hash":"","customInstructions.setting.used":!1,"customInstructions.setting.length":0};try{let o=c.H.get("ai.generateCommits.customInstructions");o&&(t["customInstructions.setting.used"]=!0,t["customInstructions.setting.length"]=o.length),this._context.operations.generateCommits.count++,e.customInstructions&&(t["customInstructions.used"]=!0,t["customInstructions.length"]=e.customInstructions.length,t["customInstructions.hash"]=(0,i.Fx)(e.customInstructions)),this._generateCommitsCancellation=new n.CancellationTokenSource,await this.host.notify(P,void 0);let s=e.hunks.map(e=>({index:e.index,fileName:e.fileName,diffHeader:e.diffHeader||`diff --git a/${e.fileName} b/${e.fileName}`,hunkHeader:e.hunkHeader,content:e.content,source:e.source})),a=e.commits.map(e=>({id:e.id,message:e.message,aiExplanation:e.aiExplanation,hunkIndices:e.hunkIndices})),r=await this.container.ai.generateCommits(s,a,e.hunkMap,{source:"composer",correlationId:this.host.instanceId},{cancellation:this._generateCommitsCancellation.token,customInstructions:e.customInstructions});if(this._generateCommitsCancellation?.token.isCancellationRequested){this._context.operations.generateCommits.cancelledCount++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(L,void 0);return}if(r&&"cancelled"!==r){if(0===r.commits.length){this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":"no commits generated"}),await this.host.notify(Z,{operation:"generate commits",error:"No commits generated"});return}let o=r.commits.map((e,t)=>({id:`ai-commit-${t}`,message:e.message,aiExplanation:e.explanation,hunkIndices:e.hunks.map(e=>e.hunk)}));this._context.commits.autoComposedCount=o.length,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose":"composer/action/compose",t),await this.host.notify($,{commits:o})}else"cancelled"===r?(this._context.operations.generateCommits.cancelledCount++,await this.host.notify(L,void 0)):(this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":"unknown error"}),await this.host.notify(Z,{operation:"generate commits",error:void 0}))}catch(o){this._generateCommitsCancellation?.token.isCancellationRequested?(this._context.operations.generateCommits.cancelledCount++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(L,void 0)):(this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":o instanceof Error?o.message:"unknown error"}),await this.host.notify(Z,{operation:"generate commits",error:o instanceof Error?o.message:void 0}))}finally{this._generateCommitsCancellation?.dispose(),this._generateCommitsCancellation=void 0}}async onGenerateCommitMessage(e){let t={"customInstructions.setting.used":!1,"customInstructions.setting.length":0,overwriteExistingMessage:e.overwriteExistingMessage??!1};try{let o=c.H.get("ai.generateCommitMessage.customInstructions");o&&(t["customInstructions.setting.used"]=!0,t["customInstructions.setting.length"]=o.length),this._context.operations.generateCommitMessage.count++,this._generateCommitMessageCancellation=new n.CancellationTokenSource,await this.host.notify(N,{commitId:e.commitId});let i=await this.container.ai.generateCommitMessage(e.diff,{source:"composer",correlationId:this.host.instanceId},{cancellation:this._generateCommitMessageCancellation.token});if(this._generateCommitMessageCancellation?.token.isCancellationRequested){this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(V,void 0);return}if(i&&"cancelled"!==i){let o=i.parsed.body?`${i.parsed.summary}

${i.parsed.body}`:i.parsed.summary;this.sendTelemetryEvent("composer/action/generateCommitMessage",t),await this.host.notify(Q,{commitId:e.commitId,message:o})}else"cancelled"===i?(this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(V,void 0)):(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":"unknown error"}),await this.host.notify(Z,{operation:"generate commit message",error:void 0}))}catch(e){this._generateCommitMessageCancellation?.token.isCancellationRequested?(this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(V,void 0)):(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":e instanceof Error?e.message:"unknown error"}),await this.host.notify(Z,{operation:"generate commit message",error:e instanceof Error?e.message:void 0}))}finally{this._generateCommitMessageCancellation?.dispose(),this._generateCommitMessageCancellation=void 0}}async onFinishAndCommit(e){try{var t,o;let s,a;await this.host.notify(G,void 0);let r=this.container.git.getRepository(e.safetyState.repoPath);if(!r){await this.host.notify(U,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++;let e="Repository is no longer available";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(W,{error:e});return}let c=e.hunks.filter(t=>e.commits.some(e=>e.hunkIndices.includes(t.index))),d=await ei(r,e.safetyState,c);if(!d.isValid){await this.host.notify(U,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e=d.errors.join(`
`);this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(W,{error:e});return}let m=(t=e.commits,o=e.hunks,t.map(e=>{let{patch:t,filePatches:n}=function(e,t){let o=e.hunkIndices.map(e=>t.find(t=>t.index===e)).filter(e=>void 0!==e);if(0===o.length)return{patch:"",filePatches:new Map};let n=new Map;for(let e of o){let t=e.diffHeader||`diff --git a/${e.fileName} b/${e.fileName}`,o=n.get(t);if(null==o&&(o=[],n.set(t,o)),e.isRename)o.push("");else{let t=`${e.hunkHeader}
${e.content}`;o.push(t)}}let i="";for(let[e,t]of n.entries()){i+=`${e.trim()}
`;let o=t.filter(e=>""!==e.trim());o.length>0&&(i+=`${o.join(`
`)}
`)}return{patch:i,filePatches:n}}(e,o);return{message:e.message,explanation:e.aiExplanation,filePatches:n,patch:t}})),h=this.container.git.getRepositoryService(r.path);if(!h){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="No repository service found";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}let l=await r.git.patch?.createUnreachableCommitsFromPatches(e.baseCommit.sha,m);if(!l?.length){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Failed to create commits from patches";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}let u=(await r.git.diff.getDiff?.(l[l.length-1],e.baseCommit.sha,{notation:"..."}))?.contents;if(!u){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Failed to get combined diff";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}if(!function(e,t,o){let{hashes:n}=e;return t===(o?n.unified:n.staged)}(e.safetyState,await (0,i.sc)(u),this._context.diff.unstagedIncluded)){await this.host.notify(U,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Output diff does not match input";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(W,{error:e});return}let g=await h.stash?.getStash();if(g?.stashes.size){let e=g.stashes.values().next().value;e&&(s=e)}let p=`Commit composer: ${new Date().toLocaleString()}`;await h.stash?.saveStash(p,void 0,{includeUntracked:!0}),g=await h.stash?.getStash();let f=!1;g?.stashes.size&&(a=g.stashes.values().next().value)&&a.ref!==s?.ref&&a.message===p&&(f=!0),await h.reset(l[l.length-1],{hard:!0}),a&&f&&await h.stash?.applyStash(a.stashName,{deleteAfter:!0}),this._context.commits.finalCount=l.length,this.sendTelemetryEvent("composer/action/finishAndCommit"),await this.host.notify(U,void 0),n.commands.executeCommand("workbench.action.closeActiveEditor")}catch(t){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e=t instanceof Error?t.message:"unknown error";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(U,void 0),n.window.showErrorMessage(`Failed to commit changes: ${e}`)}}onAnyConfigurationChanged(e){if(c.H.changed(e,"ai.enabled")){let e=c.H.get("ai.enabled",void 0,!0);this._context.ai.enabled.config=e,this.host.notify(K,{config:e})}}onContextChanged(e){if("gitlens:gk:organization:ai:enabled"===e){let e=(0,d.SD)("gitlens:gk:organization:ai:enabled",!0);this._context.ai.enabled.org=e,this.host.notify(K,{org:e})}}onAIModelChanged(e){this.updateAiModel()}getAiEnabled(){return{org:(0,d.SD)("gitlens:gk:organization:ai:enabled",!0),config:c.H.get("ai.enabled",void 0,!0)}}sendTelemetryEvent(e,t){this.container.telemetry.enabled&&this.container.telemetry.sendEvent(e,{...this.getTelemetryContext(),...t})}}}};